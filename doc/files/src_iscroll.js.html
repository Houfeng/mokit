<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/iscroll.js - Mokit API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../logo.png" title="Mokit API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v2.0 Beta 34</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Ajax.html">Ajax</a></li>
            
                <li><a href="../classes/App.html">App</a></li>
            
                <li><a href="../classes/Base64.html">Base64</a></li>
            
                <li><a href="../classes/Class.html">Class</a></li>
            
                <li><a href="../classes/Console.html">Console</a></li>
            
                <li><a href="../classes/Context.html">Context</a></li>
            
                <li><a href="../classes/Controller.html">Controller</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Grid.html">Grid</a></li>
            
                <li><a href="../classes/Json.html">Json</a></li>
            
                <li><a href="../classes/Language.html">Language</a></li>
            
                <li><a href="../classes/Mask.html">Mask</a></li>
            
                <li><a href="../classes/Model.html">Model</a></li>
            
                <li><a href="../classes/Move.html">Move</a></li>
            
                <li><a href="../classes/Navigation.html">Navigation</a></li>
            
                <li><a href="../classes/Route.html">Route</a></li>
            
                <li><a href="../classes/Sortable.html">Sortable</a></li>
            
                <li><a href="../classes/Store.html">Store</a></li>
            
                <li><a href="../classes/Style.html">Style</a></li>
            
                <li><a href="../classes/Task.html">Task</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/View.html">View</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/mokit.html">mokit</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/iscroll.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * iScroll v4.2.5 ~ Copyright (c) 2012 Matteo Spinelli, http://cubiq.org
 * Released under MIT license, http://cubiq.org/license
 */
(function(window, doc) {
    var m = Math,
        dummyStyle = doc.createElement(&#x27;div&#x27;).style,
        vendor = (function() {
            var vendors = &#x27;t,webkitT,MozT,msT,OT&#x27;.split(&#x27;,&#x27;),
                t,
                i = 0,
                l = vendors.length;

            for (; i &lt; l; i++) {
                t = vendors[i] + &#x27;ransform&#x27;;
                if (t in dummyStyle) {
                    return vendors[i].substr(0, vendors[i].length - 1);
                }
            }

            return false;
        })(),
        cssVendor = vendor ? &#x27;-&#x27; + vendor.toLowerCase() + &#x27;-&#x27; : &#x27;&#x27;,

        // Style properties
        transform = prefixStyle(&#x27;transform&#x27;),
        transitionProperty = prefixStyle(&#x27;transitionProperty&#x27;),
        transitionDuration = prefixStyle(&#x27;transitionDuration&#x27;),
        transformOrigin = prefixStyle(&#x27;transformOrigin&#x27;),
        transitionTimingFunction = prefixStyle(&#x27;transitionTimingFunction&#x27;),
        transitionDelay = prefixStyle(&#x27;transitionDelay&#x27;),

        // Browser capabilities
        isAndroid = (/android/gi).test(navigator.appVersion),
        isIDevice = (/iphone|ipad/gi).test(navigator.appVersion),
        isTouchPad = (/hp-tablet/gi).test(navigator.appVersion),

        has3d = prefixStyle(&#x27;perspective&#x27;) in dummyStyle,
        hasTouch = &#x27;ontouchstart&#x27; in window &amp;&amp; !isTouchPad,
        hasTransform = vendor !== false,
        hasTransitionEnd = prefixStyle(&#x27;transition&#x27;) in dummyStyle,

        RESIZE_EV = &#x27;onorientationchange&#x27; in window ? &#x27;orientationchange&#x27; : &#x27;resize&#x27;,
        START_EV = hasTouch ? &#x27;touchstart&#x27; : &#x27;mousedown&#x27;,
        MOVE_EV = hasTouch ? &#x27;touchmove&#x27; : &#x27;mousemove&#x27;,
        END_EV = hasTouch ? &#x27;touchend&#x27; : &#x27;mouseup&#x27;,
        CANCEL_EV = hasTouch ? &#x27;touchcancel&#x27; : &#x27;mouseup&#x27;,
        TRNEND_EV = (function() {
            if (vendor === false) return false;

            var transitionEnd = {
                &#x27;&#x27;: &#x27;transitionend&#x27;,
                &#x27;webkit&#x27;: &#x27;webkitTransitionEnd&#x27;,
                &#x27;Moz&#x27;: &#x27;transitionend&#x27;,
                &#x27;O&#x27;: &#x27;otransitionend&#x27;,
                &#x27;ms&#x27;: &#x27;MSTransitionEnd&#x27;
            };

            return transitionEnd[vendor];
        })(),

        nextFrame = (function() {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(callback) {
                    return setTimeout(callback, 1);
                };
        })(),
        cancelFrame = (function() {
            return window.cancelRequestAnimationFrame ||
                window.webkitCancelAnimationFrame ||
                window.webkitCancelRequestAnimationFrame ||
                window.mozCancelRequestAnimationFrame ||
                window.oCancelRequestAnimationFrame ||
                window.msCancelRequestAnimationFrame ||
                clearTimeout;
        })(),

        // Helpers
        translateZ = has3d ? &#x27; translateZ(0)&#x27; : &#x27;&#x27;,

        // Constructor
        iScroll = function(el, options) {
            var that = this,
                i;

            that.wrapper = typeof el == &#x27;object&#x27; ? el : doc.getElementById(el);
            that.wrapper.style.overflow = &#x27;hidden&#x27;;
            that.scroller = that.wrapper.children[0];

            // Default options
            that.options = {
                hScroll: true,
                vScroll: true,
                x: 0,
                y: 0,
                bounce: true,
                bounceLock: false,
                momentum: true,
                lockDirection: true,
                useTransform: true,
                useTransition: false,
                topOffset: 0,
                checkDOMChanges: false, // Experimental
                handleClick: true,

                // Scrollbar
                hScrollbar: true,
                vScrollbar: true,
                fixedScrollbar: isAndroid,
                hideScrollbar: isIDevice,
                fadeScrollbar: isIDevice &amp;&amp; has3d,
                scrollbarClass: &#x27;&#x27;,

                // Zoom
                zoom: false,
                zoomMin: 1,
                zoomMax: 4,
                doubleTapZoom: 2,
                wheelAction: &#x27;scroll&#x27;,

                // Snap
                snap: false,
                snapThreshold: 1,

                // Events
                onRefresh: null,
                onBeforeScrollStart: function(e) {
                    e.preventDefault();
                },
                onScrollStart: null,
                onBeforeScrollMove: null,
                onScrollMove: null,
                onBeforeScrollEnd: null,
                onScrollEnd: null,
                onTouchEnd: null,
                onDestroy: null,
                onZoomStart: null,
                onZoom: null,
                onZoomEnd: null
            };

            // User defined options
            for (i in options) that.options[i] = options[i];

            // Set starting position
            that.x = that.options.x;
            that.y = that.options.y;

            // Normalize options
            that.options.useTransform = hasTransform &amp;&amp; that.options.useTransform;
            that.options.hScrollbar = that.options.hScroll &amp;&amp; that.options.hScrollbar;
            that.options.vScrollbar = that.options.vScroll &amp;&amp; that.options.vScrollbar;
            that.options.zoom = that.options.useTransform &amp;&amp; that.options.zoom;
            that.options.useTransition = hasTransitionEnd &amp;&amp; that.options.useTransition;

            // Helpers FIX ANDROID BUG!
            // translate3d and scale doesn&#x27;t work together!
            // Ignoring 3d ONLY WHEN YOU SET that.options.zoom
            if (that.options.zoom &amp;&amp; isAndroid) {
                translateZ = &#x27;&#x27;;
            }

            // Set some default styles
            that.scroller.style[transitionProperty] = that.options.useTransform ? cssVendor + &#x27;transform&#x27; : &#x27;top left&#x27;;
            that.scroller.style[transitionDuration] = &#x27;0&#x27;;
            that.scroller.style[transformOrigin] = &#x27;0 0&#x27;;
            if (that.options.useTransition) that.scroller.style[transitionTimingFunction] = &#x27;cubic-bezier(0.33,0.66,0.66,1)&#x27;;

            if (that.options.useTransform) that.scroller.style[transform] = &#x27;translate(&#x27; + that.x + &#x27;px,&#x27; + that.y + &#x27;px)&#x27; + translateZ;
            else that.scroller.style.cssText += &#x27;;position:absolute;top:&#x27; + that.y + &#x27;px;left:&#x27; + that.x + &#x27;px&#x27;;

            if (that.options.useTransition) that.options.fixedScrollbar = true;

            that.refresh();

            that._bind(RESIZE_EV, window);
            that._bind(START_EV);
            if (!hasTouch) {
                if (that.options.wheelAction != &#x27;none&#x27;) {
                    that._bind(&#x27;DOMMouseScroll&#x27;);
                    that._bind(&#x27;mousewheel&#x27;);
                }
            }

            if (that.options.checkDOMChanges) that.checkDOMTime = setInterval(function() {
                that._checkDOMChanges();
            }, 500);
        };

    // Prototype
    iScroll.prototype = {
        enabled: true,
        x: 0,
        y: 0,
        steps: [],
        scale: 1,
        currPageX: 0,
        currPageY: 0,
        pagesX: [],
        pagesY: [],
        aniTime: null,
        wheelZoomCount: 0,

        handleEvent: function(e) {
            var that = this;
            switch (e.type) {
                case START_EV:
                    if (!hasTouch &amp;&amp; e.button !== 0) return;
                    that._start(e);
                    break;
                case MOVE_EV:
                    that._move(e);
                    break;
                case END_EV:
                case CANCEL_EV:
                    that._end(e);
                    break;
                case RESIZE_EV:
                    that._resize();
                    break;
                case &#x27;DOMMouseScroll&#x27;:
                case &#x27;mousewheel&#x27;:
                    that._wheel(e);
                    break;
                case TRNEND_EV:
                    that._transitionEnd(e);
                    break;
            }
        },

        _checkDOMChanges: function() {
            if (this.moved || this.zoomed || this.animating ||
                (this.scrollerW == this.scroller.offsetWidth * this.scale &amp;&amp; this.scrollerH == this.scroller.offsetHeight * this.scale)) return;

            this.refresh();
        },

        _scrollbar: function(dir) {
            var that = this,
                bar;

            if (!that[dir + &#x27;Scrollbar&#x27;]) {
                if (that[dir + &#x27;ScrollbarWrapper&#x27;]) {
                    if (hasTransform) that[dir + &#x27;ScrollbarIndicator&#x27;].style[transform] = &#x27;&#x27;;
                    that[dir + &#x27;ScrollbarWrapper&#x27;].parentNode.removeChild(that[dir + &#x27;ScrollbarWrapper&#x27;]);
                    that[dir + &#x27;ScrollbarWrapper&#x27;] = null;
                    that[dir + &#x27;ScrollbarIndicator&#x27;] = null;
                }

                return;
            }

            if (!that[dir + &#x27;ScrollbarWrapper&#x27;]) {
                // Create the scrollbar wrapper
                bar = doc.createElement(&#x27;div&#x27;);

                if (that.options.scrollbarClass) bar.className = that.options.scrollbarClass + dir.toUpperCase();
                else bar.style.cssText = &#x27;position:absolute;z-index:100;&#x27; + (dir == &#x27;h&#x27; ? &#x27;height:7px;bottom:1px;left:2px;right:&#x27; + (that.vScrollbar ? &#x27;7&#x27; : &#x27;2&#x27;) + &#x27;px&#x27; : &#x27;width:7px;bottom:&#x27; + (that.hScrollbar ? &#x27;7&#x27; : &#x27;2&#x27;) + &#x27;px;top:2px;right:1px&#x27;);

                bar.style.cssText += &#x27;;pointer-events:none;&#x27; + cssVendor + &#x27;transition-property:opacity;&#x27; + cssVendor + &#x27;transition-duration:&#x27; + (that.options.fadeScrollbar ? &#x27;350ms&#x27; : &#x27;0&#x27;) + &#x27;;overflow:hidden;opacity:&#x27; + (that.options.hideScrollbar ? &#x27;0&#x27; : &#x27;1&#x27;);

                that.wrapper.appendChild(bar);
                that[dir + &#x27;ScrollbarWrapper&#x27;] = bar;

                // Create the scrollbar indicator
                bar = doc.createElement(&#x27;div&#x27;);
                if (!that.options.scrollbarClass) {
                    bar.style.cssText = &#x27;position:absolute;z-index:100;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);&#x27; + cssVendor + &#x27;background-clip:padding-box;&#x27; + cssVendor + &#x27;box-sizing:border-box;&#x27; + (dir == &#x27;h&#x27; ? &#x27;height:100%&#x27; : &#x27;width:100%&#x27;) + &#x27;;&#x27; + cssVendor + &#x27;border-radius:3px;border-radius:3px&#x27;;
                }
                bar.style.cssText += &#x27;;pointer-events:none;&#x27; + cssVendor + &#x27;transition-property:&#x27; + cssVendor + &#x27;transform;&#x27; + cssVendor + &#x27;transition-timing-function:cubic-bezier(0.33,0.66,0.66,1);&#x27; + cssVendor + &#x27;transition-duration:0;&#x27; + cssVendor + &#x27;transform: translate(0,0)&#x27; + translateZ;
                if (that.options.useTransition) bar.style.cssText += &#x27;;&#x27; + cssVendor + &#x27;transition-timing-function:cubic-bezier(0.33,0.66,0.66,1)&#x27;;

                that[dir + &#x27;ScrollbarWrapper&#x27;].appendChild(bar);
                that[dir + &#x27;ScrollbarIndicator&#x27;] = bar;
            }

            if (dir == &#x27;h&#x27;) {
                that.hScrollbarSize = that.hScrollbarWrapper.clientWidth;
                that.hScrollbarIndicatorSize = m.max(m.round(that.hScrollbarSize * that.hScrollbarSize / that.scrollerW), 8);
                that.hScrollbarIndicator.style.width = that.hScrollbarIndicatorSize + &#x27;px&#x27;;
                that.hScrollbarMaxScroll = that.hScrollbarSize - that.hScrollbarIndicatorSize;
                that.hScrollbarProp = that.hScrollbarMaxScroll / that.maxScrollX;
            } else {
                that.vScrollbarSize = that.vScrollbarWrapper.clientHeight;
                that.vScrollbarIndicatorSize = m.max(m.round(that.vScrollbarSize * that.vScrollbarSize / that.scrollerH), 8);
                that.vScrollbarIndicator.style.height = that.vScrollbarIndicatorSize + &#x27;px&#x27;;
                that.vScrollbarMaxScroll = that.vScrollbarSize - that.vScrollbarIndicatorSize;
                that.vScrollbarProp = that.vScrollbarMaxScroll / that.maxScrollY;
            }

            // Reset position
            that._scrollbarPos(dir, true);
        },

        _resize: function() {
            var that = this;
            setTimeout(function() {
                that.refresh();
            }, isAndroid ? 200 : 0);
        },

        _pos: function(x, y) {
            if (this.zoomed) return;

            x = this.hScroll ? x : 0;
            y = this.vScroll ? y : 0;

            if (this.options.useTransform) {
                this.scroller.style[transform] = &#x27;translate(&#x27; + x + &#x27;px,&#x27; + y + &#x27;px) scale(&#x27; + this.scale + &#x27;)&#x27; + translateZ;
            } else {
                x = m.round(x);
                y = m.round(y);
                this.scroller.style.left = x + &#x27;px&#x27;;
                this.scroller.style.top = y + &#x27;px&#x27;;
            }

            this.x = x;
            this.y = y;

            this._scrollbarPos(&#x27;h&#x27;);
            this._scrollbarPos(&#x27;v&#x27;);
        },

        _scrollbarPos: function(dir, hidden) {
            var that = this,
                pos = dir == &#x27;h&#x27; ? that.x : that.y,
                size;

            if (!that[dir + &#x27;Scrollbar&#x27;]) return;

            pos = that[dir + &#x27;ScrollbarProp&#x27;] * pos;

            if (pos &lt; 0) {
                if (!that.options.fixedScrollbar) {
                    size = that[dir + &#x27;ScrollbarIndicatorSize&#x27;] + m.round(pos * 3);
                    if (size &lt; 8) size = 8;
                    that[dir + &#x27;ScrollbarIndicator&#x27;].style[dir == &#x27;h&#x27; ? &#x27;width&#x27; : &#x27;height&#x27;] = size + &#x27;px&#x27;;
                }
                pos = 0;
            } else if (pos &gt; that[dir + &#x27;ScrollbarMaxScroll&#x27;]) {
                if (!that.options.fixedScrollbar) {
                    size = that[dir + &#x27;ScrollbarIndicatorSize&#x27;] - m.round((pos - that[dir + &#x27;ScrollbarMaxScroll&#x27;]) * 3);
                    if (size &lt; 8) size = 8;
                    that[dir + &#x27;ScrollbarIndicator&#x27;].style[dir == &#x27;h&#x27; ? &#x27;width&#x27; : &#x27;height&#x27;] = size + &#x27;px&#x27;;
                    pos = that[dir + &#x27;ScrollbarMaxScroll&#x27;] + (that[dir + &#x27;ScrollbarIndicatorSize&#x27;] - size);
                } else {
                    pos = that[dir + &#x27;ScrollbarMaxScroll&#x27;];
                }
            }

            that[dir + &#x27;ScrollbarWrapper&#x27;].style[transitionDelay] = &#x27;0&#x27;;
            that[dir + &#x27;ScrollbarWrapper&#x27;].style.opacity = hidden &amp;&amp; that.options.hideScrollbar ? &#x27;0&#x27; : &#x27;1&#x27;;
            that[dir + &#x27;ScrollbarIndicator&#x27;].style[transform] = &#x27;translate(&#x27; + (dir == &#x27;h&#x27; ? pos + &#x27;px,0)&#x27; : &#x27;0,&#x27; + pos + &#x27;px)&#x27;) + translateZ;
        },

        _start: function(e) {
            var that = this,
                point = hasTouch ? e.touches[0] : e,
                matrix, x, y,
                c1, c2;

            if (!that.enabled) return;

            if (that.options.onBeforeScrollStart) that.options.onBeforeScrollStart.call(that, e);

            if (that.options.useTransition || that.options.zoom) that._transitionTime(0);

            that.moved = false;
            that.animating = false;
            that.zoomed = false;
            that.distX = 0;
            that.distY = 0;
            that.absDistX = 0;
            that.absDistY = 0;
            that.dirX = 0;
            that.dirY = 0;

            // Gesture start
            if (that.options.zoom &amp;&amp; hasTouch &amp;&amp; e.touches.length &gt; 1) {
                c1 = m.abs(e.touches[0].pageX - e.touches[1].pageX);
                c2 = m.abs(e.touches[0].pageY - e.touches[1].pageY);
                that.touchesDistStart = m.sqrt(c1 * c1 + c2 * c2);

                that.originX = m.abs(e.touches[0].pageX + e.touches[1].pageX - that.wrapperOffsetLeft * 2) / 2 - that.x;
                that.originY = m.abs(e.touches[0].pageY + e.touches[1].pageY - that.wrapperOffsetTop * 2) / 2 - that.y;

                if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
            }

            if (that.options.momentum) {
                if (that.options.useTransform) {
                    // Very lame general purpose alternative to CSSMatrix
                    matrix = getComputedStyle(that.scroller, null)[transform].replace(/[^0-9\-.,]/g, &#x27;&#x27;).split(&#x27;,&#x27;);
                    x = +(matrix[12] || matrix[4]);
                    y = +(matrix[13] || matrix[5]);
                } else {
                    x = +getComputedStyle(that.scroller, null).left.replace(/[^0-9-]/g, &#x27;&#x27;);
                    y = +getComputedStyle(that.scroller, null).top.replace(/[^0-9-]/g, &#x27;&#x27;);
                }

                if (x != that.x || y != that.y) {
                    if (that.options.useTransition) that._unbind(TRNEND_EV);
                    else cancelFrame(that.aniTime);
                    that.steps = [];
                    that._pos(x, y);
                    if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);
                }
            }

            that.absStartX = that.x; // Needed by snap threshold
            that.absStartY = that.y;

            that.startX = that.x;
            that.startY = that.y;
            that.pointX = point.pageX;
            that.pointY = point.pageY;

            that.startTime = e.timeStamp || Date.now();

            if (that.options.onScrollStart) that.options.onScrollStart.call(that, e);

            that._bind(MOVE_EV, window);
            that._bind(END_EV, window);
            that._bind(CANCEL_EV, window);
        },

        _move: function(e) {
            var that = this,
                point = hasTouch ? e.touches[0] : e,
                deltaX = point.pageX - that.pointX,
                deltaY = point.pageY - that.pointY,
                newX = that.x + deltaX,
                newY = that.y + deltaY,
                c1, c2, scale,
                timestamp = e.timeStamp || Date.now();

            if (that.options.onBeforeScrollMove) that.options.onBeforeScrollMove.call(that, e);

            // Zoom
            if (that.options.zoom &amp;&amp; hasTouch &amp;&amp; e.touches.length &gt; 1) {
                c1 = m.abs(e.touches[0].pageX - e.touches[1].pageX);
                c2 = m.abs(e.touches[0].pageY - e.touches[1].pageY);
                that.touchesDist = m.sqrt(c1 * c1 + c2 * c2);

                that.zoomed = true;

                scale = 1 / that.touchesDistStart * that.touchesDist * this.scale;

                if (scale &lt; that.options.zoomMin) scale = 0.5 * that.options.zoomMin * Math.pow(2.0, scale / that.options.zoomMin);
                else if (scale &gt; that.options.zoomMax) scale = 2.0 * that.options.zoomMax * Math.pow(0.5, that.options.zoomMax / scale);

                that.lastScale = scale / this.scale;

                newX = this.originX - this.originX * that.lastScale + this.x,
                    newY = this.originY - this.originY * that.lastScale + this.y;

                this.scroller.style[transform] = &#x27;translate(&#x27; + newX + &#x27;px,&#x27; + newY + &#x27;px) scale(&#x27; + scale + &#x27;)&#x27; + translateZ;

                if (that.options.onZoom) that.options.onZoom.call(that, e);
                return;
            }

            that.pointX = point.pageX;
            that.pointY = point.pageY;

            // Slow down if outside of the boundaries
            if (newX &gt; 0 || newX &lt; that.maxScrollX) {
                newX = that.options.bounce ? that.x + (deltaX / 2) : newX &gt;= 0 || that.maxScrollX &gt;= 0 ? 0 : that.maxScrollX;
            }
            if (newY &gt; that.minScrollY || newY &lt; that.maxScrollY) {
                newY = that.options.bounce ? that.y + (deltaY / 2) : newY &gt;= that.minScrollY || that.maxScrollY &gt;= 0 ? that.minScrollY : that.maxScrollY;
            }

            that.distX += deltaX;
            that.distY += deltaY;
            that.absDistX = m.abs(that.distX);
            that.absDistY = m.abs(that.distY);

            if (that.absDistX &lt; 6 &amp;&amp; that.absDistY &lt; 6) {
                return;
            }

            // Lock direction
            if (that.options.lockDirection) {
                if (that.absDistX &gt; that.absDistY + 5) {
                    newY = that.y;
                    deltaY = 0;
                } else if (that.absDistY &gt; that.absDistX + 5) {
                    newX = that.x;
                    deltaX = 0;
                }
            }

            that.moved = true;
            that._pos(newX, newY);
            that.dirX = deltaX &gt; 0 ? -1 : deltaX &lt; 0 ? 1 : 0;
            that.dirY = deltaY &gt; 0 ? -1 : deltaY &lt; 0 ? 1 : 0;

            if (timestamp - that.startTime &gt; 300) {
                that.startTime = timestamp;
                that.startX = that.x;
                that.startY = that.y;
            }

            if (that.options.onScrollMove) that.options.onScrollMove.call(that, e);
        },

        _end: function(e) {
            if (hasTouch &amp;&amp; e.touches.length !== 0) return;

            var that = this,
                point = hasTouch ? e.changedTouches[0] : e,
                target, ev,
                momentumX = {
                    dist: 0,
                    time: 0
                },
                momentumY = {
                    dist: 0,
                    time: 0
                },
                duration = (e.timeStamp || Date.now()) - that.startTime,
                newPosX = that.x,
                newPosY = that.y,
                distX, distY,
                newDuration,
                snap,
                scale;

            that._unbind(MOVE_EV, window);
            that._unbind(END_EV, window);
            that._unbind(CANCEL_EV, window);

            if (that.options.onBeforeScrollEnd) that.options.onBeforeScrollEnd.call(that, e);

            if (that.zoomed) {
                scale = that.scale * that.lastScale;
                scale = Math.max(that.options.zoomMin, scale);
                scale = Math.min(that.options.zoomMax, scale);
                that.lastScale = scale / that.scale;
                that.scale = scale;

                that.x = that.originX - that.originX * that.lastScale + that.x;
                that.y = that.originY - that.originY * that.lastScale + that.y;

                that.scroller.style[transitionDuration] = &#x27;200ms&#x27;;
                that.scroller.style[transform] = &#x27;translate(&#x27; + that.x + &#x27;px,&#x27; + that.y + &#x27;px) scale(&#x27; + that.scale + &#x27;)&#x27; + translateZ;

                that.zoomed = false;
                that.refresh();

                if (that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
                return;
            }

            if (!that.moved) {
                if (hasTouch) {
                    if (that.doubleTapTimer &amp;&amp; that.options.zoom) {
                        // Double tapped
                        clearTimeout(that.doubleTapTimer);
                        that.doubleTapTimer = null;
                        if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
                        that.zoom(that.pointX, that.pointY, that.scale == 1 ? that.options.doubleTapZoom : 1);
                        if (that.options.onZoomEnd) {
                            setTimeout(function() {
                                that.options.onZoomEnd.call(that, e);
                            }, 200); // 200 is default zoom duration
                        }
                    } else if (this.options.handleClick) {
                        that.doubleTapTimer = setTimeout(function() {
                            that.doubleTapTimer = null;

                            // Find the last touched element
                            target = point.target;
                            while (target.nodeType != 1) target = target.parentNode;

                            if (true || (target.tagName != &#x27;SELECT&#x27; &amp;&amp; target.tagName != &#x27;INPUT&#x27; &amp;&amp; target.tagName != &#x27;TEXTAREA&#x27;)) {
                                ev = doc.createEvent(&#x27;MouseEvents&#x27;);
                                ev.initMouseEvent(&#x27;click&#x27;, true, true, e.view, 1,
                                    point.screenX, point.screenY, point.clientX, point.clientY,
                                    e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
                                    0, null);
                                ev._fake = true;
                                target.dispatchEvent(ev);
                            }
                        }, that.options.zoom ? 250 : 0);
                    }
                }

                that._resetPos(400);

                if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
                return;
            }

            if (duration &lt; 300 &amp;&amp; that.options.momentum) {
                momentumX = newPosX ? that._momentum(newPosX - that.startX, duration, -that.x, that.scrollerW - that.wrapperW + that.x, that.options.bounce ? that.wrapperW : 0) : momentumX;
                momentumY = newPosY ? that._momentum(newPosY - that.startY, duration, -that.y, (that.maxScrollY &lt; 0 ? that.scrollerH - that.wrapperH + that.y - that.minScrollY : 0), that.options.bounce ? that.wrapperH : 0) : momentumY;

                newPosX = that.x + momentumX.dist;
                newPosY = that.y + momentumY.dist;

                if ((that.x &gt; 0 &amp;&amp; newPosX &gt; 0) || (that.x &lt; that.maxScrollX &amp;&amp; newPosX &lt; that.maxScrollX)) momentumX = {
                    dist: 0,
                    time: 0
                };
                if ((that.y &gt; that.minScrollY &amp;&amp; newPosY &gt; that.minScrollY) || (that.y &lt; that.maxScrollY &amp;&amp; newPosY &lt; that.maxScrollY)) momentumY = {
                    dist: 0,
                    time: 0
                };
            }

            if (momentumX.dist || momentumY.dist) {
                newDuration = m.max(m.max(momentumX.time, momentumY.time), 10);

                // Do we need to snap?
                if (that.options.snap) {
                    distX = newPosX - that.absStartX;
                    distY = newPosY - that.absStartY;
                    if (m.abs(distX) &lt; that.options.snapThreshold &amp;&amp; m.abs(distY) &lt; that.options.snapThreshold) {
                        that.scrollTo(that.absStartX, that.absStartY, 200);
                    } else {
                        snap = that._snap(newPosX, newPosY);
                        newPosX = snap.x;
                        newPosY = snap.y;
                        newDuration = m.max(snap.time, newDuration);
                    }
                }

                that.scrollTo(m.round(newPosX), m.round(newPosY), newDuration);

                if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
                return;
            }

            // Do we need to snap?
            if (that.options.snap) {
                distX = newPosX - that.absStartX;
                distY = newPosY - that.absStartY;
                if (m.abs(distX) &lt; that.options.snapThreshold &amp;&amp; m.abs(distY) &lt; that.options.snapThreshold) that.scrollTo(that.absStartX, that.absStartY, 200);
                else {
                    snap = that._snap(that.x, that.y);
                    if (snap.x != that.x || snap.y != that.y) that.scrollTo(snap.x, snap.y, snap.time);
                }

                if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
                return;
            }

            that._resetPos(200);
            if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
        },

        _resetPos: function(time) {
            var that = this,
                resetX = that.x &gt;= 0 ? 0 : that.x &lt; that.maxScrollX ? that.maxScrollX : that.x,
                resetY = that.y &gt;= that.minScrollY || that.maxScrollY &gt; 0 ? that.minScrollY : that.y &lt; that.maxScrollY ? that.maxScrollY : that.y;

            if (resetX == that.x &amp;&amp; resetY == that.y) {
                if (that.moved) {
                    that.moved = false;
                    if (that.options.onScrollEnd) that.options.onScrollEnd.call(that); // Execute custom code on scroll end
                }

                if (that.hScrollbar &amp;&amp; that.options.hideScrollbar) {
                    if (vendor == &#x27;webkit&#x27;) that.hScrollbarWrapper.style[transitionDelay] = &#x27;300ms&#x27;;
                    that.hScrollbarWrapper.style.opacity = &#x27;0&#x27;;
                }
                if (that.vScrollbar &amp;&amp; that.options.hideScrollbar) {
                    if (vendor == &#x27;webkit&#x27;) that.vScrollbarWrapper.style[transitionDelay] = &#x27;300ms&#x27;;
                    that.vScrollbarWrapper.style.opacity = &#x27;0&#x27;;
                }

                return;
            }

            that.scrollTo(resetX, resetY, time || 0);
        },

        _wheel: function(e) {
            var that = this,
                wheelDeltaX, wheelDeltaY,
                deltaX, deltaY,
                deltaScale;

            if (&#x27;wheelDeltaX&#x27; in e) {
                wheelDeltaX = e.wheelDeltaX / 12;
                wheelDeltaY = e.wheelDeltaY / 12;
            } else if (&#x27;wheelDelta&#x27; in e) {
                wheelDeltaX = wheelDeltaY = e.wheelDelta / 12;
            } else if (&#x27;detail&#x27; in e) {
                wheelDeltaX = wheelDeltaY = -e.detail * 3;
            } else {
                return;
            }

            if (that.options.wheelAction == &#x27;zoom&#x27;) {
                deltaScale = that.scale * Math.pow(2, 1 / 3 * (wheelDeltaY ? wheelDeltaY / Math.abs(wheelDeltaY) : 0));
                if (deltaScale &lt; that.options.zoomMin) deltaScale = that.options.zoomMin;
                if (deltaScale &gt; that.options.zoomMax) deltaScale = that.options.zoomMax;

                if (deltaScale != that.scale) {
                    if (!that.wheelZoomCount &amp;&amp; that.options.onZoomStart) that.options.onZoomStart.call(that, e);
                    that.wheelZoomCount++;

                    that.zoom(e.pageX, e.pageY, deltaScale, 400);

                    setTimeout(function() {
                        that.wheelZoomCount--;
                        if (!that.wheelZoomCount &amp;&amp; that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
                    }, 400);
                }

                return;
            }

            deltaX = that.x + wheelDeltaX;
            deltaY = that.y + wheelDeltaY;

            if (deltaX &gt; 0) deltaX = 0;
            else if (deltaX &lt; that.maxScrollX) deltaX = that.maxScrollX;

            if (deltaY &gt; that.minScrollY) deltaY = that.minScrollY;
            else if (deltaY &lt; that.maxScrollY) deltaY = that.maxScrollY;

            if (that.maxScrollY &lt; 0) {
                that.scrollTo(deltaX, deltaY, 0);
            }
        },

        _transitionEnd: function(e) {
            var that = this;

            if (e.target != that.scroller) return;

            that._unbind(TRNEND_EV);

            that._startAni();
        },


        /**
         *
         * Utilities
         *
         */
        _startAni: function() {
            var that = this,
                startX = that.x,
                startY = that.y,
                startTime = Date.now(),
                step, easeOut,
                animate;

            if (that.animating) return;

            if (!that.steps.length) {
                that._resetPos(400);
                return;
            }

            step = that.steps.shift();

            if (step.x == startX &amp;&amp; step.y == startY) step.time = 0;

            that.animating = true;
            that.moved = true;

            if (that.options.useTransition) {
                that._transitionTime(step.time);
                that._pos(step.x, step.y);
                that.animating = false;
                if (step.time) that._bind(TRNEND_EV);
                else that._resetPos(0);
                return;
            }

            animate = function() {
                var now = Date.now(),
                    newX, newY;

                if (now &gt;= startTime + step.time) {
                    that._pos(step.x, step.y);
                    that.animating = false;
                    if (that.options.onAnimationEnd) that.options.onAnimationEnd.call(that); // Execute custom code on animation end
                    that._startAni();
                    return;
                }

                now = (now - startTime) / step.time - 1;
                easeOut = m.sqrt(1 - now * now);
                newX = (step.x - startX) * easeOut + startX;
                newY = (step.y - startY) * easeOut + startY;
                that._pos(newX, newY);
                if (that.animating) that.aniTime = nextFrame(animate);
            };

            animate();
        },

        _transitionTime: function(time) {
            time += &#x27;ms&#x27;;
            this.scroller.style[transitionDuration] = time;
            if (this.hScrollbar) this.hScrollbarIndicator.style[transitionDuration] = time;
            if (this.vScrollbar) this.vScrollbarIndicator.style[transitionDuration] = time;
        },

        _momentum: function(dist, time, maxDistUpper, maxDistLower, size) {
            var deceleration = 0.0006,
                speed = m.abs(dist) / time,
                newDist = (speed * speed) / (2 * deceleration),
                newTime = 0,
                outsideDist = 0;

            // Proportinally reduce speed if we are outside of the boundaries
            if (dist &gt; 0 &amp;&amp; newDist &gt; maxDistUpper) {
                outsideDist = size / (6 / (newDist / speed * deceleration));
                maxDistUpper = maxDistUpper + outsideDist;
                speed = speed * maxDistUpper / newDist;
                newDist = maxDistUpper;
            } else if (dist &lt; 0 &amp;&amp; newDist &gt; maxDistLower) {
                outsideDist = size / (6 / (newDist / speed * deceleration));
                maxDistLower = maxDistLower + outsideDist;
                speed = speed * maxDistLower / newDist;
                newDist = maxDistLower;
            }

            newDist = newDist * (dist &lt; 0 ? -1 : 1);
            newTime = speed / deceleration;

            return {
                dist: newDist,
                time: m.round(newTime)
            };
        },

        _offset: function(el) {
            var left = -el.offsetLeft,
                top = -el.offsetTop;

            while (el = el.offsetParent) {
                left -= el.offsetLeft;
                top -= el.offsetTop;
            }

            if (el != this.wrapper) {
                left *= this.scale;
                top *= this.scale;
            }

            return {
                left: left,
                top: top
            };
        },

        _snap: function(x, y) {
            var that = this,
                i, l,
                page, time,
                sizeX, sizeY;

            // Check page X
            page = that.pagesX.length - 1;
            for (i = 0, l = that.pagesX.length; i &lt; l; i++) {
                if (x &gt;= that.pagesX[i]) {
                    page = i;
                    break;
                }
            }
            if (page == that.currPageX &amp;&amp; page &gt; 0 &amp;&amp; that.dirX &lt; 0) page--;
            x = that.pagesX[page];
            sizeX = m.abs(x - that.pagesX[that.currPageX]);
            sizeX = sizeX ? m.abs(that.x - x) / sizeX * 500 : 0;
            that.currPageX = page;

            // Check page Y
            page = that.pagesY.length - 1;
            for (i = 0; i &lt; page; i++) {
                if (y &gt;= that.pagesY[i]) {
                    page = i;
                    break;
                }
            }
            if (page == that.currPageY &amp;&amp; page &gt; 0 &amp;&amp; that.dirY &lt; 0) page--;
            y = that.pagesY[page];
            sizeY = m.abs(y - that.pagesY[that.currPageY]);
            sizeY = sizeY ? m.abs(that.y - y) / sizeY * 500 : 0;
            that.currPageY = page;

            // Snap with constant speed (proportional duration)
            time = m.round(m.max(sizeX, sizeY)) || 200;

            return {
                x: x,
                y: y,
                time: time
            };
        },

        _bind: function(type, el, bubble) {
            (el || this.scroller).addEventListener(type, this, !!bubble);
        },

        _unbind: function(type, el, bubble) {
            (el || this.scroller).removeEventListener(type, this, !!bubble);
        },


        /**
         *
         * Public methods
         *
         */
        destroy: function() {
            var that = this;

            that.scroller.style[transform] = &#x27;&#x27;;

            // Remove the scrollbars
            that.hScrollbar = false;
            that.vScrollbar = false;
            that._scrollbar(&#x27;h&#x27;);
            that._scrollbar(&#x27;v&#x27;);

            // Remove the event listeners
            that._unbind(RESIZE_EV, window);
            that._unbind(START_EV);
            that._unbind(MOVE_EV, window);
            that._unbind(END_EV, window);
            that._unbind(CANCEL_EV, window);

            if (!that.options.hasTouch) {
                that._unbind(&#x27;DOMMouseScroll&#x27;);
                that._unbind(&#x27;mousewheel&#x27;);
            }

            if (that.options.useTransition) that._unbind(TRNEND_EV);

            if (that.options.checkDOMChanges) clearInterval(that.checkDOMTime);

            if (that.options.onDestroy) that.options.onDestroy.call(that);
        },

        refresh: function() {
            var that = this,
                offset,
                i, l,
                els,
                pos = 0,
                page = 0;

            if (that.scale &lt; that.options.zoomMin) that.scale = that.options.zoomMin;
            that.wrapperW = that.wrapper.clientWidth || 1;
            that.wrapperH = that.wrapper.clientHeight || 1;

            that.minScrollY = -that.options.topOffset || 0;
            that.scrollerW = m.round(that.scroller.offsetWidth * that.scale);
            that.scrollerH = m.round((that.scroller.offsetHeight + that.minScrollY) * that.scale);
            that.maxScrollX = that.wrapperW - that.scrollerW;
            that.maxScrollY = that.wrapperH - that.scrollerH + that.minScrollY;
            that.dirX = 0;
            that.dirY = 0;

            if (that.options.onRefresh) that.options.onRefresh.call(that);

            that.hScroll = that.options.hScroll &amp;&amp; that.maxScrollX &lt; 0;
            that.vScroll = that.options.vScroll &amp;&amp; (!that.options.bounceLock &amp;&amp; !that.hScroll || that.scrollerH &gt; that.wrapperH);

            that.hScrollbar = that.hScroll &amp;&amp; that.options.hScrollbar;
            that.vScrollbar = that.vScroll &amp;&amp; that.options.vScrollbar &amp;&amp; that.scrollerH &gt; that.wrapperH;

            offset = that._offset(that.wrapper);
            that.wrapperOffsetLeft = -offset.left;
            that.wrapperOffsetTop = -offset.top;

            // Prepare snap
            if (typeof that.options.snap == &#x27;string&#x27;) {
                that.pagesX = [];
                that.pagesY = [];
                els = that.scroller.querySelectorAll(that.options.snap);
                for (i = 0, l = els.length; i &lt; l; i++) {
                    pos = that._offset(els[i]);
                    pos.left += that.wrapperOffsetLeft;
                    pos.top += that.wrapperOffsetTop;
                    that.pagesX[i] = pos.left &lt; that.maxScrollX ? that.maxScrollX : pos.left * that.scale;
                    that.pagesY[i] = pos.top &lt; that.maxScrollY ? that.maxScrollY : pos.top * that.scale;
                }
            } else if (that.options.snap) {
                that.pagesX = [];
                while (pos &gt;= that.maxScrollX) {
                    that.pagesX[page] = pos;
                    pos = pos - that.wrapperW;
                    page++;
                }
                if (that.maxScrollX % that.wrapperW) that.pagesX[that.pagesX.length] = that.maxScrollX - that.pagesX[that.pagesX.length - 1] + that.pagesX[that.pagesX.length - 1];

                pos = 0;
                page = 0;
                that.pagesY = [];
                while (pos &gt;= that.maxScrollY) {
                    that.pagesY[page] = pos;
                    pos = pos - that.wrapperH;
                    page++;
                }
                if (that.maxScrollY % that.wrapperH) that.pagesY[that.pagesY.length] = that.maxScrollY - that.pagesY[that.pagesY.length - 1] + that.pagesY[that.pagesY.length - 1];
            }

            // Prepare the scrollbars
            that._scrollbar(&#x27;h&#x27;);
            that._scrollbar(&#x27;v&#x27;);

            if (!that.zoomed) {
                that.scroller.style[transitionDuration] = &#x27;0&#x27;;
                that._resetPos(400);
            }
        },

        scrollTo: function(x, y, time, relative) {
            var that = this,
                step = x,
                i, l;

            that.stop();

            if (!step.length) step = [{
                x: x,
                y: y,
                time: time,
                relative: relative
            }];

            for (i = 0, l = step.length; i &lt; l; i++) {
                if (step[i].relative) {
                    step[i].x = that.x - step[i].x;
                    step[i].y = that.y - step[i].y;
                }
                that.steps.push({
                    x: step[i].x,
                    y: step[i].y,
                    time: step[i].time || 0
                });
            }

            that._startAni();
        },

        scrollToElement: function(el, time) {
            var that = this,
                pos;
            el = el.nodeType ? el : that.scroller.querySelector(el);
            if (!el) return;

            pos = that._offset(el);
            pos.left += that.wrapperOffsetLeft;
            pos.top += that.wrapperOffsetTop;

            pos.left = pos.left &gt; 0 ? 0 : pos.left &lt; that.maxScrollX ? that.maxScrollX : pos.left;
            pos.top = pos.top &gt; that.minScrollY ? that.minScrollY : pos.top &lt; that.maxScrollY ? that.maxScrollY : pos.top;
            time = time === undefined ? m.max(m.abs(pos.left) * 2, m.abs(pos.top) * 2) : time;

            that.scrollTo(pos.left, pos.top, time);
        },

        scrollToPage: function(pageX, pageY, time) {
            var that = this,
                x, y;

            time = time === undefined ? 400 : time;

            if (that.options.onScrollStart) that.options.onScrollStart.call(that);

            if (that.options.snap) {
                pageX = pageX == &#x27;next&#x27; ? that.currPageX + 1 : pageX == &#x27;prev&#x27; ? that.currPageX - 1 : pageX;
                pageY = pageY == &#x27;next&#x27; ? that.currPageY + 1 : pageY == &#x27;prev&#x27; ? that.currPageY - 1 : pageY;

                pageX = pageX &lt; 0 ? 0 : pageX &gt; that.pagesX.length - 1 ? that.pagesX.length - 1 : pageX;
                pageY = pageY &lt; 0 ? 0 : pageY &gt; that.pagesY.length - 1 ? that.pagesY.length - 1 : pageY;

                that.currPageX = pageX;
                that.currPageY = pageY;
                x = that.pagesX[pageX];
                y = that.pagesY[pageY];
            } else {
                x = -that.wrapperW * pageX;
                y = -that.wrapperH * pageY;
                if (x &lt; that.maxScrollX) x = that.maxScrollX;
                if (y &lt; that.maxScrollY) y = that.maxScrollY;
            }

            that.scrollTo(x, y, time);
        },

        disable: function() {
            this.stop();
            this._resetPos(0);
            this.enabled = false;

            // If disabled after touchstart we make sure that there are no left over events
            this._unbind(MOVE_EV, window);
            this._unbind(END_EV, window);
            this._unbind(CANCEL_EV, window);
        },

        enable: function() {
            this.enabled = true;
        },

        stop: function() {
            if (this.options.useTransition) this._unbind(TRNEND_EV);
            else cancelFrame(this.aniTime);
            this.steps = [];
            this.moved = false;
            this.animating = false;
        },

        zoom: function(x, y, scale, time) {
            var that = this,
                relScale = scale / that.scale;

            if (!that.options.useTransform) return;

            that.zoomed = true;
            time = time === undefined ? 200 : time;
            x = x - that.wrapperOffsetLeft - that.x;
            y = y - that.wrapperOffsetTop - that.y;
            that.x = x - x * relScale + that.x;
            that.y = y - y * relScale + that.y;

            that.scale = scale;
            that.refresh();

            that.x = that.x &gt; 0 ? 0 : that.x &lt; that.maxScrollX ? that.maxScrollX : that.x;
            that.y = that.y &gt; that.minScrollY ? that.minScrollY : that.y &lt; that.maxScrollY ? that.maxScrollY : that.y;

            that.scroller.style[transitionDuration] = time + &#x27;ms&#x27;;
            that.scroller.style[transform] = &#x27;translate(&#x27; + that.x + &#x27;px,&#x27; + that.y + &#x27;px) scale(&#x27; + scale + &#x27;)&#x27; + translateZ;
            that.zoomed = false;
        },

        isReady: function() {
            return !this.moved &amp;&amp; !this.zoomed &amp;&amp; !this.animating;
        }
    };

    function prefixStyle(style) {
        if (vendor === &#x27;&#x27;) return style;

        style = style.charAt(0).toUpperCase() + style.substr(1);
        return vendor + style;
    }

    dummyStyle = null; // for the sake of it

    if (typeof exports !== &#x27;undefined&#x27;) exports.iScroll = iScroll;
    else window.iScroll = iScroll;

})(window, document);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
